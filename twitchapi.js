/* eslint-disable no-trailing-spaces */

const { writeFileSync } = require("node:fs");
const TwitchTokenPath = process.cwd() + "/node_modules/@ix-xs/twitch.api/Token.json";
let TwitchToken = require(TwitchTokenPath);

module.exports = class {

	/**
	 * **Instance client**
	 * 
	 * ---
	 * @param {{
	 * client_id:string,
	 * client_secret:string,
	 * }} config - Vos identifiants client Twitch
	 * 
	 * ---
	 * @example
	 * const client = new twitchAPI({ client_id:"votre_client_id", client_secret:"votre_client_secret" });
	 */
	constructor(config) {

        this.clientId = config.client_id;
        this.clientSecret = config.client_secret;
        this.token = TwitchToken;
        this.validateInterval = null;

	}

    /**
     * ğŸ‘€ **DÃ©marre le client**  
     * ğŸ’¡ **Note** : Cette fonction est requise afin de dÃ©marrer la surveillance du token qui doit maintenant Ãªtre valider toutes les heures
     * 
     * ---
     * @example
     * await client.initialize();
     */
	async initialize() {
        if (this.isExpiredToken()) {
            await this.refreshToken();
        }
        await this.validateToken();
        this.startPeriodicValidation();
    }
	/**
	 * ğŸ‘€ **GÃ©nÃ¨re un nouveau token**  
	 * ğŸ’¡ **Note** : Le token se gÃ¨re de faÃ§on automatique, cette fonction sert uniquement a son auto-gestion
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:{
	 * created_at:number,
	 * access_token:string,
	 * expires_in:number,
	 * token_type:string,
	 * }
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la gÃ©nÃ©ration du token  
	 * â€¢ `result?` : RÃ©sultat  
	 * > â€¢ `created_at` : Date de la crÃ©ation du token  
	 * > â€¢ `access_token` : Le code (token) gÃ©nÃ©rÃ©  
	 * > â€¢ `expires_in` : DÃ©lais (en secondes) de l'expiration du token  
	 * > â€¢ `token_type` : Le type du token ("Bearer")
	 * 
	 * ---
	 * @example
	 * client.generateToken().then(console.log);
	 * 
	 * // Exemple de rÃ©ponse :
	 * // {
	 * //   ok: true,
	 * //   result: {
	 * //     created_at: 1637167088,
	 * //     access_token: "abcdefgh123456789",
	 * //     expires_in: 3600,
	 * //     token_type: "Bearer",
	 * //   },
	 * // }
	 */
	async generateToken() {
        try {
            const response = await fetch(`https://id.twitch.tv/oauth2/token?client_id=${this.clientId}&client_secret=${this.clientSecret}&grant_type=client_credentials`, {
                method: "POST",
            });

            if (!response.ok) {
                return { ok: false, statusText: response.statusText };
            }

            const result = await response.json();
            result.token_type = "Bearer";
            result.created_at = new Date().getTime();
            this.updateTokenFile(result);
            return { ok: true, result };
        } catch (error) {
            return { ok: false, error: error.stack };
        }
    }
	/**
	 * ğŸ‘€ **Renvoi la validitÃ© du token actuel**
	 * 
	 * ---
	 * @returns {boolean} **Renvoi `true` si le token a expirÃ©, sinon `false`**
	 * 
	 * ---
	 * @example
	 * console.log(client.isExpiredToken());
	 * 
	 * // Exemple de rÃ©ponse :
	 * // true
	 */
	isExpiredToken() {
        if (!this.token.access_token || this.token.access_token === "") {
            return true;
        }

        const now = Math.floor(Date.now() / 1000);
        const createdAt = Math.floor(this.token.created_at / 1000);
        const expiresIn = this.token.expires_in;
        const expirationTime = createdAt + expiresIn;

        return now >= expirationTime;
    }
	/**
	 * ğŸ‘€ **GÃ©nÃ¨re un nouveau token**  
	 * ğŸ’¡ **Note** : Le token se gÃ¨re de faÃ§on automatique, cette fonction sert uniquement a son auto-gestion
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:{
	 * created_at:number,
	 * access_token:string,
	 * expires_in:number,
	 * token_type:string,
	 * }
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la gÃ©nÃ©ration du token  
	 * â€¢ `result?` : RÃ©sultat  
	 * > â€¢ `created_at` : Date de la crÃ©ation du token  
	 * > â€¢ `access_token` : Le code (token) gÃ©nÃ©rÃ©  
	 * > â€¢ `expires_in` : DÃ©lais (en secondes) de l'expiration du token  
	 * > â€¢ `token_type` : Le type du token ("Bearer")
	 * 
	 * ---
	 * @example
	 * client.refreshToken().then(console.log);
	 * 
	 * // Exemple de rÃ©ponse :
	 * // {
	 * //   ok: true,
	 * //   result: {
	 * //     created_at: 1637167088,
	 * //     access_token: "abcdefgh123456789",
	 * //     expires_in: 3600,
	 * //     token_type: "Bearer",
	 * //   },
	 * // }
	 */
	async refreshToken() {
        try {
            const newToken = await this.generateToken();

            if (!newToken.ok) {
                return { ok: false, error: newToken.error ?? newToken.statusText };
            }

            this.updateTokenFile(newToken.result);
            return { ok: true, result: newToken.result };
        } catch (error) {
            return { ok: false, error: error.stack };
        }
    }
    /**
     * ğŸ‘€ **Valide le token**  
     * ğŸ’¡ **Note** : Le token se gÃ¨re de faÃ§on automatique, cette fonction sert uniquement a son auto-gestion
     * 
     * ---
     * @example
     * await client.validateToken();
     */
	async validateToken() {
        try {
            if (!this.token.access_token || this.token.access_token === "") {
                await this.refreshToken();
            }

            const response = await fetch(`https://id.twitch.tv/oauth2/validate`, {
                headers: {
                    Authorization: `Bearer ${this.token.access_token}`
                }
            });

            if (!response.ok) {
                if (response.status === 401) {
                    await this.refreshToken();
                    return this.validateToken();
                }
                return { ok: false, statusText: response.statusText };
            }

            const result = await response.json();
            return { ok: true, result };
        } catch (error) {
            return { ok: false, error: error.stack };
        }
    }
    /**
     * ğŸ‘€ **Met Ã  jour le token**  
     * ğŸ’¡ **Note** : Le token se gÃ¨re de faÃ§on automatique, cette fonction sert uniquement a son auto-gestion
     * 
     * ---
     * @example
     * await client.updateTokenFile();
     */
	updateTokenFile(tokenData) {
        writeFileSync(TwitchTokenPath, JSON.stringify(tokenData, null, 4));
        this.token = tokenData;
        TwitchToken = tokenData;
    }
    /**
     * ğŸ‘€ **DÃ©marre la surveillance pour la validation periodique du token (toutes les heures)**  
     * ğŸ’¡ **Note** : Le token se gÃ¨re de faÃ§on automatique, cette fonction sert uniquement a son auto-gestion
     * 
     * ---
     * @example
     * await client.startPeriodicValidation();
     */
	startPeriodicValidation() {
        if (this.validateInterval) {
            clearInterval(this.validateInterval);
        }
        this.validateInterval = setInterval(async () => {
            const validation = await this.validateToken();
            if (!validation.ok) {
                console.error("Token validation failed:", validation.error || validation.statusText);
            }
        }, 3600000); // 1 hour in milliseconds
    }
	/**
	 * ğŸ‘€ **Renvoi une liste des streams**  
	 * ğŸ’¡ **Note** : La liste est classÃ©e par ordre dÃ©croissant du nombre de tÃ©lÃ©spectateurs regardant le flux. Ã‰tant donnÃ© que les spectateurs vont et viennent pendant un flux, il est possible de trouver des flux en double ou manquants dans la liste au fur et Ã  mesure que vous parcourez les rÃ©sultats.
	 * 
	 * ---
	 * @param {{
	 * users_names?:Array<string>,
	 * games_names?:Array<string>,
	 * type?:"all"|"live",
	 * languages?:Array<string>,
	 * first?:number,
	 * before?:string,
	 * after?:string,
	 * }} [params] **ParamÃ¨tres de filtrage** :
	 * 
	 * â€¢ `users_names` : Les noms d'utilisateurs utilisÃ©s pour filtrer la liste des flux. Renvoie uniquement les flux des utilisateurs qui diffusent. Vous pouvez spÃ©cifier un maximum de 100 noms d'utilisateurs.  
	 * â€¢ `games_names` : Les noms des jeux (catÃ©gories) utilisÃ©s pour filtrer la liste des flux. Renvoie uniquement les flux qui diffusent les jeux (catÃ©gories). Vous pouvez spÃ©cifier un maximum de 100 noms.  
	 * â€¢ `type` : Type de flux par lequel filtrer la liste des flux. Par dÃ©faut : "all".  
	 * â€¢ `languages` : Un code de langue utilisÃ© pour filtrer la liste des flux. Renvoie uniquement les flux diffusÃ©s dans la langue spÃ©cifiÃ©e. SpÃ©cifiez la langue Ã  l'aide d'un code de langue Ã  deux lettres ISO 639-1 ou autre si la diffusion utilise une langue ne figurant pas dans la liste des [langues de diffusion prises en charge](https://help.twitch.tv/s/article/linguals-on-twitch?langue=en_US#streamlang). Vous pouvez spÃ©cifier un maximum de 100 codes de langue.  
	 * â€¢ `first` : Nombre maximum d'Ã©lÃ©ments Ã  renvoyer par page dans la rÃ©ponse. La taille minimale de la page est de 1 Ã©lÃ©ment par page et la taille maximale est de 100 Ã©lÃ©ments par page. La valeur par dÃ©faut est 20.  
	 * â€¢ `before` : Le curseur utilisÃ© pour obtenir la page de rÃ©sultats prÃ©cÃ©dente. L'objet Pagination dans la rÃ©ponse contient la valeur du curseur. [Lire la suite](https://dev.twitch.tv/docs/api/guide/#pagination)  
	 * â€¢ `after` : Le curseur utilisÃ© pour obtenir la page suivante de rÃ©sultats. L'objet Pagination dans la rÃ©ponse contient la valeur du curseur. [Lire la suite](https://dev.twitch.tv/docs/api/guide/#pagination)  
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:Array<{
	 * id:string,
	 * user_id:string,
	 * user_login:string,
	 * user_name:string,
	 * game_id:string,
	 * game_name:string,
	 * type:"live"|"",
	 * title:string|"",
	 * tags:Array<string>,
	 * viewer_count:number,
	 * started_at:string,
	 * language:string,
	 * thumbnail_url:string,
	 * tag_ids:[],
	 * is_mature:boolean
	 * }>
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des streams  
	 * â€¢ `result?` La liste des flux.  
	 * > â€¢ `id` Un identifiant qui identifie le flux. Vous pourrez utiliser cet identifiant ultÃ©rieurement pour rechercher la vidÃ©o Ã  la demande (VOD).  
	 * > â€¢ `user_id` L'ID de l'utilisateur qui diffuse le flux.  
	 * > â€¢ `user_login` Le nom de connexion de l'utilisateur.  
	 * > â€¢ `user_name` Le nom d'affichage de l'utilisateur.  
	 * > â€¢ `game_id` L'ID de la catÃ©gorie ou du jeu en cours de lecture.  
	 * > â€¢ `game_name` Le nom de la catÃ©gorie ou du jeu en cours.  
	 * > â€¢ `type` Le type de flux. Si une erreur se produit, ce champ est dÃ©fini sur une chaÃ®ne vide.  
	 * > â€¢ `title` Le titre du flux. Est une chaÃ®ne vide si elle n'est pas dÃ©finie.  
	 * > â€¢ `tags` Les balises appliquÃ©es au flux.  
	 * > â€¢ `viewer_count` Le nombre d'utilisateurs regardant le flux.  
	 * > â€¢ `started_at` La date et l'heure UTC (au format RFC3339) du dÃ©but de la diffusion.  
	 * > â€¢ `langue` La langue utilisÃ©e par le flux. Il s'agit d'un code de langue Ã  deux lettres ISO 639-1 ou autre si le flux utilise une langue qui ne figure pas dans la liste des [langues de flux prises en charge](https://help.twitch.tv/s/article/linguals-on-twitch?langue=en_US#streamlang).  
	 * > â€¢ `thumbnail_url` Une URL vers une image d'une image des 5 derniÃ¨res minutes du flux. Remplacez les espaces rÃ©servÃ©s de largeur et de hauteur dans l'URL (**{width}x{height}**) par la taille de l'image souhaitÃ©e, en pixels.  
	 * > â€¢ `tag_ids` **IMPORTANT** Depuis le 28 fÃ©vrier 2023, ce champ est obsolÃ¨te et renvoie uniquement un tableau vide.  
	 * > â€¢ `is_mature` Une valeur boolÃ©enne qui indique si le flux est destinÃ© Ã  un public adulte.
	 * 
	 * ---
	 * @example
	 * client.getStreams().then(console.log); // Obtient des informations sur les 20 flux les plus actifs.
	 * 
	 * client.getStreams({
 		users_names:["twitchdev"]
	 }).then(console.log); // Obtient les flux pour les connexions spÃ©cifiÃ©es. Si lâ€™utilisateur nâ€™est pas en direct, la rÃ©ponse ne lâ€™inclut pas.
	 */
	async getStreams(params) {

		try {

			let link = `https://api.twitch.tv/helix/streams`;
			const linkParams = [];

			if (params) {

				if (params.after) {
					linkParams.push(`after=${params.after}`);
				}

				if (params.before) {
					linkParams.push(`before=${params.before}`);
				}

				if (params.first) {
					linkParams.push(`first=${params.first}`);
				}

				if (params.games_names) {
					const games = await this.getGames(params.games_names);
					if (!games.ok) {
						return { ok:false, error:games.error ?? games.statusText };
					}
					const ids = games.result.map(game => game.id);
					linkParams.push(`game_id=${ids.slice(0, 100).join('&game_id=')}`);
				}

				if (params.languages) {
					linkParams.push(`language=${params.languages.slice(0, 100).join('&language=')}`);
				}

				if (params.type) {
					linkParams.push(`type=${params.type}`);
				}

				if (params.users_names) {
					const users = await this.getUsers(params.users_names);
					if (!users.ok) {
						return { ok:false, error:users.error ?? users.statusText };
					}
					const userIds = users.result.map(user => user.id);
					linkParams.push(`user_id=${userIds.slice(0, 100).join('&user_id=')}`);
				}

			}

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			link += "?" + linkParams.join("&");

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}
	}
	/**
	 * ğŸ‘€ **Renvoi les informations d'un ou plusieurs utilisateur(s)**
	 * 
	 * ---
	 * @param {Array<string>} usernames Les noms d'utilisateur des utilisateurs Ã  obtenir. Le nombre maximum de noms d'utilisateur que vous pouvez spÃ©cifier est de 100.
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * result?:Array<{
	 * id:string,
	 * display_name:string,
	 * broadcaster_type:""|"affiliate"|"partner",
	 * description:string,
	 * profile_image_url:string,
	 * offline_image_url:string,
	 * view_count:number,
	 * created_at:string
	 * }>
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des utilisateurs  
	 * â€¢ `result?` La liste des utilisateurs.  
	 * > â€¢ `id` Un identifiant qui identifie l'utilisateur.  
	 * > â€¢ `login` Le nom d'affichage de l'utilisateur.  
	 * > â€¢ `type` Le type d'utilisateur.  
	 * > â€¢ `broadcaster_type` Le type de diffuseur.  
	 * > â€¢ `description` La description de l'utilisateur sur sa chaÃ®ne.  
	 * > â€¢ `profile_image_url` Une URL vers l'image de profil de l'utilisateur.  
	 * > â€¢ `offline_image_url` Une URL vers l'image hors ligne de l'utilisateur.  
	 * > â€¢ `view_count` **REMARQUE** : ce champ est obsolÃ¨te (voir [Point de terminaison de l'API Get Users â€“ DÃ©prÃ©ciation de Â« view_count Â»)](https://discuss.dev.twitch.tv/t/get-users-api -endpoint-view-count-deprecation/37777)). Toutes les donnÃ©es contenues dans ce champ ne sont pas valides et ne doivent pas Ãªtre utilisÃ©es.  
	 * > â€¢ `created_at` La date et l'heure UTC auxquelles le compte de l'utilisateur a Ã©tÃ© crÃ©Ã©. L'horodatage est au format RFC3339.
	 * 
	 * ---
	 * @example
	 client.getUsers(["twitchdev"]).then(console.log);
	 */
	async getUsers(usernames) {

		try {

			const map = usernames.splice(0, 100).join('&login=');
			const link = `https://api.twitch.tv/helix/users?login=${map}`;
	
			if (this.isExpiredToken()) {
				await this.refreshToken();
			}
	
			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});
	
			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}
	
			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}

	}
	/**
	 * ğŸ‘€ **Renvoi une liste de Cheermotes que les utilisateurs peuvent utiliser pour encourager Bits dans la salle de discussion de n'importe quelle chaÃ®ne compatible Bits.**  
	 * ğŸ’¡ **Note** : Les cheermotes sont des Ã©moticÃ´nes animÃ©es auxquelles les spectateurs peuvent attribuer des Bits.
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:Array<{
	 * prefix:string,
	 * tiers:Array<{
	 * min_bits:number,
	 * id:"1"|"100"|"500"|"1000"|"5000"|"10000"|"100000",
	 * color:string,
	 * images:{
	 * dark:{
	 * animated:{
	 * "1":string,
	 * "1.5":string,
	 * "2":string,
	 * "3":string,
	 * "4":string,
	 * },
	 * static:{
	 * "1":string,
	 * "1.5":string,
	 * "2":string,
	 * "3":string,
	 * "4":string,
	 * },
	 * },
	 * light:{
	 * animated:{
	 * "1":string,
	 * "1.5":string,
	 * "2":string,
	 * "3":string,
	 * "4":string,
	 * },
	 * static:{
	 * "1":string,
	 * "1.5":string,
	 * "2":string,
	 * "3":string,
	 * "4":string,
	 * },
	 * },
	 * },
	 * can_cheer:boolean,
	 * show_in_bits_card:boolean,
	 * }>,
	 * type:"global_first_party"|"global_third_party"|"channel_custom"|"display_only"|"sponsored",
	 * order:number,
	 * last_updated:string,
	 * is_charitable:boolean,
	 * }>
	 * }>} **Renvoi une promesse d'objet** :  
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des cheermotes  
	 * â€¢ `result ?` La liste des Cheermotes. La liste est classÃ©e par ordre croissant de la valeur du champ de commande.  
	 * > â€¢ `prefix` La partie nom de la chaÃ®ne Cheermote que vous utilisez dans le chat pour encourager Bits. La chaÃ®ne Cheermote complÃ¨te est la concatÃ©nation de {prÃ©fixe} + {nombre de bits}. Par exemple, si le prÃ©fixe est Â« Cheer Â» et que vous souhaitez encourager 100 bits, la chaÃ®ne Cheermote complÃ¨te est Cheer100. Lorsque la chaÃ®ne Cheermote est saisie dans le chat, Twitch la convertit en l'image associÃ©e au niveau Bits qui a Ã©tÃ© acclamÃ©.  
	 * > â€¢ `tiers`  
	 * > > â€¢ `min_bits` Le nombre minimum de Bits que vous devez encourager Ã  ce niveau. Le nombre maximum de Bits que vous pouvez encourager Ã  ce niveau est dÃ©terminÃ© par le nombre minimum de Bits requis du niveau suivant moins 1. Par exemple, si min_bits est 1 et min_bits pour le niveau suivant est 100, la plage de Bits pour ce niveau. est compris entre 1 et 99. La valeur minimale de bits du dernier niveau est le nombre maximum de bits que vous pouvez encourager en utilisant ce Cheermote. Par exemple, 10 000.  
	 * > > â€¢ `id` Le niveau.  
	 * > > â€¢ `color` Le code hexadÃ©cimal de la couleur associÃ©e Ã  ce niveau (par exemple, #979797).  
	 * > > â€¢ `images` Les ensembles d'images animÃ©es et statiques pour le Cheermote. Le dictionnaire d'images est organisÃ© par thÃ¨me, format et taille. Les touches de thÃ¨me sont sombres et claires. Chaque thÃ¨me est un dictionnaire de formats : animÃ©s et statiques. Chaque format est un dictionnaire de tailles : 1, 1,5, 2, 3 et 4. La valeur de chaque taille contient l'URL de l'image.  
	 * > > â€¢ `can_cheer` Une valeur boolÃ©enne qui dÃ©termine si les utilisateurs peuvent encourager Ã  ce niveau.  
	 * > > â€¢ `show_in_bits_card` Une valeur boolÃ©enne qui dÃ©termine si ce niveau est affichÃ© dans la carte Bits. Est vrai si ce niveau est affichÃ© dans la carte Bits.  
	 *
	 * > â€¢ `type` Le type de Cheermote.  
	 * > â€¢ `order` L'ordre dans lequel les Cheermotes sont affichÃ©s dans la carte Bits. Les numÃ©ros ne peuvent pas Ãªtre consÃ©cutifs. Par exemple, les nombres peuvent passer de 1 Ã  7 puis Ã  13. Les numÃ©ros de commande sont uniques au sein d'un type de Cheermote (par exemple, global_first_party) mais peuvent ne pas Ãªtre uniques parmi tous les Cheermotes de la rÃ©ponse.  
	 * > â€¢ `last_updated` La date et l'heure, au format RFC3339, de la derniÃ¨re mise Ã  jour de ce Cheermote.  
	 * > â€¢ `is_charitable` Une valeur boolÃ©enne qui indique si ce Cheermote fournit une contribution caritative lors des campagnes caritatives. 
	 * 
	 * ---
	 * @example
	 client.getCheermotes().then(console.log);
	 */
	async getCheermotes() {
		
		try {

			const link = "https://api.twitch.tv/helix/bits/cheermotes";

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}

	}
	/**
	 * ğŸ‘€ **Obtient la liste des [Ã©motes globales](https://www.twitch.tv/creatorcamp/fr-fr/paths/getting-started-on-twitch/emotes/) ou la liste des Ã©motes personnalisÃ©es du diffuseur.**  
	 * ğŸ’¡ **Note** : Les Ã©motes globales sont des Ã©moticÃ´nes crÃ©Ã©es par Twitch que les utilisateurs peuvent utiliser dans n'importe quel chat Twitch.  
	 * Les diffuseurs crÃ©ent ces Ã©motes personnalisÃ©es pour les utilisateurs qui s'abonnent ou suivent la chaÃ®ne ou encouragent Bits dans la fenÃªtre de discussion de la chaÃ®ne. [En savoir plus](https://dev.twitch.tv/docs/irc/emotes/).  
	 * ğŸ’¡ **Note** : Ã€ l'exception des Ã©moticÃ´nes personnalisÃ©es, les utilisateurs peuvent utiliser des Ã©moticÃ´nes personnalisÃ©es dans n'importe quel chat Twitch.
	 * 
	 * ---
	 * @param {string} [username] Le nom d'utilisateur qui identifie le diffuseur dont vous souhaitez obtenir les Ã©moticÃ´nes.
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:Array<{
	 * id:string,
	 * name:string,
	 * images:{
	 * url_1x:string,
	 * url_2x:string,
	 * url_4x:string,
	 * },
	 * tier?:string,
	 * emote_type?:"bitstier"|"follower"|"subscriptions",
	 * emote_set_id?:string,
	 * format:Array<"static"|"animated">,
	 * scale:Array<"1.0"|"2.0"|"3.0">,
	 * theme_mode:Array<"dark"|"light">,
	 * template:string,
	 * }>
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des emotes  
	 * â€¢ `result?` La liste des Ã©moticÃ´nes globales. ou la liste des Ã©moticÃ´nes crÃ©Ã©es par le diffuseur spÃ©cifiÃ©. Si le diffuseur nâ€™a pas crÃ©Ã© dâ€™Ã©moticÃ´nes personnalisÃ©es, la liste est vide.  
	 * > â€¢ `id` Un identifiant qui identifie cette emote.  
	 * > â€¢ `name` Le nom de l'emote. Il s'agit du nom que les tÃ©lÃ©spectateurs saisissent dans la fenÃªtre de discussion pour faire apparaÃ®tre l'Ã©mote.  
	 * > â€¢ `images` Les URL des images pour l'emote. Ces URL dâ€™images fournissent toujours une image dâ€™Ã©moticÃ´ne statique et non animÃ©e avec un arriÃ¨re-plan clair. **Note** : Vous devez utiliser l'URL modÃ©lisÃ©e dans le champ du modÃ¨le pour rÃ©cupÃ©rer l'image au lieu d'utiliser ces URL.  
	 * > > â€¢ `url_1x` Une URL vers la petite version (28px x 28px) de l'emote.  
	 * > > â€¢ `url_2x` Une URL vers la version moyenne (56px x 56px) de l'emote.  
	 * > > â€¢ `url_4x` Une URL vers la grande version (112px x 112px) de l'emote.  
	 *
	 * > â€¢ `tier?` Le niveau d'abonnÃ© auquel l'emote est dÃ©verrouillÃ©e. Ce champ contient les informations de niveau uniquement si emote_type est dÃ©fini sur abonnements, sinon il s'agit d'une chaÃ®ne vide.  
	 * > â€¢ `emote_type?` Le type d'emote.  
	 * > â€¢ `emote_set_id?` Un identifiant qui identifie l'ensemble d'Ã©motes auquel appartient l'Ã©mote.  
	 * > â€¢ `format` Les formats dans lesquels l'Ã©mote est disponible. Par exemple, si l'Ã©mote est disponible uniquement au format PNG statique, le tableau ne contient que du statique. Mais si l'emote est disponible sous forme de PNG statique et de GIF animÃ©, le tableau contient des Ã©lÃ©ments statiques et animÃ©s.  
	 * > â€¢ `scale` Les tailles dans lesquelles l'emote est disponible. Par exemple, si l'emote est disponible en petites et moyennes tailles, le tableau contient 1.0 et 2.0.  
	 * > â€¢ `theme_mode` Les thÃ¨mes d'arriÃ¨re-plan dans lesquels l'emote est disponible.  
	 * > â€¢ `template` Une URL basÃ©e sur un modÃ¨le. Utilisez les valeurs des champs id, format, scale et theme_mode pour remplacer les chaÃ®nes d'espace rÃ©servÃ© de mÃªme nom dans l'URL modÃ©lisÃ©e afin de crÃ©er une URL CDN (rÃ©seau de diffusion de contenu) que vous utilisez pour rÃ©cupÃ©rer l'emote. Pour plus d'informations sur l'apparence du modÃ¨le et comment l'utiliser pour rÃ©cupÃ©rer des Ã©moticÃ´nes, consultez [Format d'URL Emote CDN](https://dev.twitch.tv/docs/irc/emotes/#cdn-template). Vous devez utiliser ce modÃ¨le au lieu d'utiliser les URL dans l'objet images.
	 * 
	 * ---
	 * @example
	 client.getChatEmotes().then(console.log); // Obtient toutes les Ã©moticÃ´nes globales.
	 client.getChatEmotes("twitchdev").then(console.log); // Obtient les Ã©moticÃ´nes personnalisÃ©es crÃ©Ã©es par la chaÃ®ne TwitchDev.
	 */
	async getChatEmotes(username) {

		try {

			let link = `https://api.twitch.tv/helix/chat/emotes/global`;

			if (username) {

				const user = await this.getUsers([username]);

				if (!user.ok) {
					return { ok:false, error:user.error ?? user.statusText };
				}

				const broadcaster_id = user.result[0]?.id;

				link = `https://api.twitch.tv/helix/chat/emotes/?broadcaster_id=${broadcaster_id}`;

			}

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}

	}
	/**
	 * ğŸ‘€ **Obtient la liste des badges de discussion de Twitch, que les utilisateurs peuvent utiliser dans la salle de discussion de n'importe quelle chaÃ®ne, ou la liste des badges de discussion personnalisÃ©s du diffuseur.**  
	 * ğŸ’¡ **Note** : Pour plus d'informations sur les badges de chat, consultez le [Guide des badges de chat Twitch](https://help.twitch.tv/s/article/twitch-chat-badges-guide?langue=en_US).  
	 * ğŸ’¡ **Note** : La liste est vide si le diffuseur n'a pas crÃ©Ã© de badges de discussion personnalisÃ©s. Pour plus d'informations sur les badges personnalisÃ©s, consultez [badges d'abonnÃ©](https://help.twitch.tv/s/article/subscriber-badge-guide?langue=en_US) et [badges Bits](https://help.twitch. tv/s/article/custom-bit-badges-guide?langue=en_US).
	 * 
	 * ---
	 * @param {string} [username] Le nom d'utilisateur
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:Array<{
	 * set_id:string,
	 * versions:Array<{
	 * id:string,
	 * image_url_1x:string,
	 * image_url_2x:string,
	 * image_url_4x:string,
	 * title:string,
	 * description:string,
	 * click_action:string|null,
	 * click_url:string|null,
	 * }>
	 * }>
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des badges  
	 * â€¢ `result?` La liste des badges de chat. La liste est triÃ©e par ordre croissant par set_id, et au sein d'un ensemble, la liste est triÃ©e par ordre croissant par id.  
	 * > â€¢ `set_id` Un identifiant qui identifie cet ensemble de badges de discussion. Par exemple, Bits ou AbonnÃ©.  
	 * > â€¢ `versions` La liste des badges de discussion dans cet ensemble.  
	 * > > â€¢ `id` Un identifiant qui identifie cette version du badge. L'ID peut Ãªtre n'importe quelle valeur. Par exemple, pour Bits, l'ID correspond au niveau de Bits, mais pour World of Warcraft, il peut s'agir d'Alliance ou de Horde.  
	 * > > â€¢ `image_url_1x` Une URL vers la petite version (18px x 18px) du badge.  
	 * > > â€¢ `image_url_2x` Une URL vers la version moyenne (36px x 36px) du badge.  
	 * > > â€¢ `image_url_4x` Une URL vers la version grande (72px x 72px) du badge.  
	 * > > â€¢ `title` Le titre du badge.  
	 * > > â€¢ `description` La description du badge.  
	 * > > â€¢ `click_action` L'action Ã  entreprendre en cliquant sur le badge. DÃ©fini sur null si aucune action n'est spÃ©cifiÃ©e.  
	 * > > â€¢ `click_url` L'URL vers laquelle accÃ©der lorsque vous cliquez sur le badge. DÃ©fini sur null si aucune URL n'est spÃ©cifiÃ©e.
	 * 
	 * ---
	 * @example
	 client.getChatBadges().then(console.log); // Obtient la liste des badges de discussion globaux.
	 client.getChatBadges("twitchdev").then(console.log); // Obtenez la liste des badges de discussion personnalisÃ©s crÃ©Ã©s par la chaÃ®ne TwitchDev Twitch.
	 */
	async getChatBadges(username) {

		try {

			let link = `https://api.twitch.tv/helix/chat/badges/global`;

			if (username) {

				const user = await this.getUsers([username]);

				if (!user.ok) {
					return { ok:false, error:user.error ?? user.statusText };
				}

				const broadcaster_id = user.result[0]?.id;

				link = `https://api.twitch.tv/helix/chat/badges/?broadcaster_id=${broadcaster_id}`;

			}

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}

	}
	/**
	 * ğŸ‘€ **Renvoi les paramÃ¨tres de discussion du diffuseur**
	 * 
	 * ---
	 * @param {string} username Le nom d'utilisateur du diffuseur dont vous souhaitez obtenir les paramÃ¨tres de discussion.
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:Array<{
	 * broadcaster_id:string,
	 * emote_mode:boolean,
	 * follower_mode:boolean,
	 * follower_mode_duration:number|null,
	 * slow_mode:boolean,
	 * slow_mode_wait_time:number|null,
	 * subscriber_mode:boolean,
	 * unique_chat_mode:boolean,
	 * }>
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des paramÃ¨tres  
	 * â€¢ `result?` La liste des paramÃ¨tres de discussion. La liste contient un seul objet avec tous les paramÃ¨tres.  
	 * > â€¢ `broadcaster_id` L'ID du diffuseur spÃ©cifiÃ© dans la requÃªte.  
	 * > â€¢ `emote_mode` Une valeur boolÃ©enne qui dÃ©termine si les messages de discussion doivent contenir uniquement des Ã©moticÃ´nes. Est vrai si les messages de discussion ne peuvent contenir que des Ã©moticÃ´nes ; sinon, faux.  
	 * > â€¢ `follower_mode` Une valeur boolÃ©enne qui dÃ©termine si le diffuseur restreint la salle de discussion aux abonnÃ©s uniquement. Est vrai si le diffuseur restreint la salle de discussion aux abonnÃ©s uniquement ; sinon, faux. Consultez le champ follower_mode_duration pour connaÃ®tre la durÃ©e pendant laquelle les utilisateurs doivent suivre le diffuseur avant de pouvoir participer au salon de discussion.  
	 * > â€¢ `follower_mode_duration` La durÃ©e, en minutes, pendant laquelle les utilisateurs doivent suivre le diffuseur avant de pouvoir participer au salon de discussion. Est nul si follower_mode est faux.  
	 * > â€¢ `slow_mode` Une valeur boolÃ©enne qui dÃ©termine si le diffuseur limite la frÃ©quence Ã  laquelle les utilisateurs de la salle de discussion sont autorisÃ©s Ã  envoyer des messages. Est vrai si le diffuseur applique un dÃ©lai ; sinon, faux. Voir le champ slow_mode_wait_time pour le dÃ©lai.  
	 * > â€¢ `slow_mode_wait_time` Le temps, en secondes, pendant lequel les utilisateurs doivent attendre entre l'envoi de messages. Est nul si slow_mode est faux.  
	 * > â€¢ `subscriber_mode` Une valeur boolÃ©enne qui dÃ©termine si seuls les utilisateurs abonnÃ©s Ã  la chaÃ®ne du diffuseur peuvent parler dans la salle de discussion. Est vrai si le diffuseur restreint le salon de discussion aux abonnÃ©s uniquement ; sinon, faux.  
	 * > â€¢ `unique_chat_mode` Une valeur boolÃ©enne qui dÃ©termine si le diffuseur demande aux utilisateurs de publier uniquement des messages uniques dans la salle de discussion. Est vrai si le diffuseur exige uniquement des messages uniques ; sinon, faux.
	 * 
	 * ---
	 * @example
	 client.getChatSettings("twitchdev").then(console.log);
	 */
	async getChatSettings(username) {

		try {

			const user = await this.getUsers([username]);

			if (!user.ok) {
				return { ok:false, error:user.error ?? user.statusText };
			}

			const broadcaster_id = user.result[0]?.id;

			const link = `https://api.twitch.tv/helix/chat/settings/?broadcaster_id=${broadcaster_id}`;

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}

	}
	/**
	 * ğŸ‘€ **Renvoi la couleur utilisÃ©e pour le nom de l'utilisateur dans le chat.**
	 * 
	 * ---
	 * @param {Array<string>} usernames L'ID de l'utilisateur dont vous souhaitez obtenir la couleur du nom d'utilisateur. L'API ignore les noms en double et les noms introuvables.
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:Array<{
	 * user_id:string,
	 * user_name:string,
	 * user_login:string,
	 * color:string,
	 * }>
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des couleurs  
	 * â€¢ `result?` La liste des utilisateurs et le code couleur qu'ils utilisent pour leur nom.  
	 * > â€¢ `user_id` Un identifiant qui identifie de maniÃ¨re unique l'utilisateur.  
	 * > â€¢ `user_login` Le nom de connexion de l'utilisateur.  
	 * > â€¢ `user_name` Le nom d'affichage de l'utilisateur.  
	 * > â€¢ `color` Le code couleur hexadÃ©cimal que l'utilisateur utilise dans le chat pour son nom. Si l'utilisateur n'a pas spÃ©cifiÃ© de couleur dans ses paramÃ¨tres, la chaÃ®ne est vide.
	 * 
	 * ---
	 * @example
	 client.getUsersChatColor(["twitchdev"]).then(console.log);
	 */
	async getUsersChatColor(usernames) {

		try {

			const users = await this.getUsers(usernames);

			if (!users.ok) {
				return { ok:false, error:users.error ?? users.statusText };
			}

			const ids = users.result.map(user => user.id);

			const map = ids.join('&user_id=');
			const link = `https://api.twitch.tv/helix/chat/color?user_id=${map}`;

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}

	}
	/**
	 * ğŸ‘€ **Obtient un ou plusieurs clips vidÃ©o capturÃ©s Ã  partir de flux**  
	 * ğŸ’¡ **Note** : Pour plus d'informations sur les clips, consultez [Comment utiliser les clips](https://help.twitch.tv/s/article/how-to-use-clips?langage=en_US).
	 * 
	 * ---
	 * @param {string} username Un nom d'utilisateur qui identifie le diffuseur dont vous souhaitez obtenir les clips vidÃ©o. Utilisez ce paramÃ¨tre pour obtenir des clips capturÃ©s Ã  partir des flux du diffuseur.
	 * 
	 * ---
	 * @param {{
	 * started_at?:string,
	 * ended_at?:string,
	 * first?:number,
	 * before?:string,
	 * after?:string
	 * }} [params] **ParamÃ¨tres de filtrage** :
	 * 
	 * â€¢ `started_at?` La date de dÃ©but utilisÃ©e pour filtrer les clips. L'API renvoie uniquement les clips situÃ©s dans la fenÃªtre de date de dÃ©but et de fin. SpÃ©cifiez la date et l'heure au format RFC3339.  
	 * â€¢ `ended_at?` La date de fin utilisÃ©e pour filtrer les clips. Si elle nâ€™est pas spÃ©cifiÃ©e, la fenÃªtre horaire correspond Ã  la date de dÃ©but plus une semaine. SpÃ©cifiez la date et l'heure au format RFC3339.  
	 * â€¢ `first?` Le nombre maximum de clips Ã  renvoyer par page dans la rÃ©ponse. La taille de page minimale est de 1 clip par page et la taille maximale est de 100. La valeur par dÃ©faut est de 20.  
	 * â€¢ `before ?` Le curseur utilisÃ© pour obtenir la page de rÃ©sultats prÃ©cÃ©dente. L'objet Pagination dans la rÃ©ponse contient la valeur du curseur. [Lire la suite](https://dev.twitch.tv/docs/api/guide/#pagination)  
	 * â€¢ `after` Le curseur utilisÃ© pour obtenir la page suivante de rÃ©sultats. L'objet Pagination dans la rÃ©ponse contient la valeur du curseur. [Lire la suite](https://dev.twitch.tv/docs/api/guide/#pagination)
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:Array<{
	 * id:string,
	 * url:string,
	 * embed_url:string,
	 * broadcaster_id:string,
	 * broadcaster_name:string,
	 * creator_id:string,
	 * creator_name:string,
	 * video_id:string,
	 * game_id:string,
	 * language:string,
	 * title:string,
	 * view_count:number,
	 * created_at:string,
	 * thumbnail_url:string,
	 * duration:number,
	 * vod_offset:number|null,
	 * }>
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des clips  
	 * â€¢ `result?` La liste des clips vidÃ©o. Pour les clips renvoyÃ©s par game_id ou Broadcaster_id, la liste est classÃ©e par ordre dÃ©croissant du nombre de vues. Pour les listes renvoyÃ©es par id, la liste est dans le mÃªme ordre que les ID d'entrÃ©e.  
	 * > â€¢ `id` Un identifiant qui identifie de maniÃ¨re unique le clip.  
	 * > â€¢ `url` Une URL vers le clip.  
	 * > â€¢ `embed_url` Une URL que vous pouvez utiliser dans une iframe pour intÃ©grer le clip (voir [IntÃ©gration de vidÃ©os et de clips](https://dev.twitch.tv/docs/embed/video-and-clips/)).  
	 * > â€¢ `broadcaster_id` Un identifiant qui identifie le diffuseur Ã  partir duquel la vidÃ©o a Ã©tÃ© extraite.  
	 * > â€¢ `broadcaster_name` Le nom d'affichage du diffuseur.  
	 * > â€¢ `creator_id` Un identifiant qui identifie l'utilisateur qui a crÃ©Ã© le clip.  
	 * > â€¢ `creator_name` Le nom d'affichage de l'utilisateur.  
	 * > â€¢ `video_id` Un identifiant qui identifie la vidÃ©o d'oÃ¹ provient le clip. Ce champ contient une chaÃ®ne vide si la vidÃ©o n'est pas disponible.  
	 * > â€¢ `game_id` L'ID du jeu en cours de lecture lors de la crÃ©ation du clip.  
	 * > â€¢ `langue` Le code de langue Ã  deux lettres ISO 639-1 dans lequel le diffuseur diffuse. Par exemple, en pour l'anglais. La valeur est diffÃ©rente si le diffuseur utilise une langue que Twitch ne prend pas en charge.  
	 * > â€¢ `title` Le titre du clip.  
	 * > â€¢ `view_count` Le nombre de fois que le clip a Ã©tÃ© visionnÃ©.  
	 * > â€¢ `created_at` La date et l'heure de crÃ©ation du clip. La date et l'heure sont au format RFC3339.  
	 * > â€¢ `thumbnail_url` Une URL vers une image miniature du clip.  
	 * > â€¢ `duration` La durÃ©e du clip, en secondes. La prÃ©cision est de 0,1.  
	 * > â€¢ `vod_offset` Le dÃ©calage de base zÃ©ro, en secondes, par rapport Ã  l'endroit oÃ¹ le clip commence dans la vidÃ©o (VOD). Est nul si la vidÃ©o n'est pas disponible ou n'a pas encore Ã©tÃ© crÃ©Ã©e Ã  partir du flux en direct (voir video_id). Notez quâ€™il existe un dÃ©lai entre le moment oÃ¹ un clip est crÃ©Ã© lors dâ€™une diffusion et le moment oÃ¹ le dÃ©calage est dÃ©fini. Pendant la pÃ©riode de retard, vod_offset est nul. Le dÃ©lai est indÃ©terminÃ© mais dure gÃ©nÃ©ralement quelques minutes.
	 * 
	 * ---
	 * @example
	 client.getClips("twitchdev").then(console.log);
	 */
	async getClips(username, params = {}) {

		try {

			const user = await this.getUsers([username]);

			if (!user.ok) {
				return { ok:false, error:user.error ?? user.statusText };
			}

			const broadcaster_id = user.result[0]?.id;

			let link = `https://api.twitch.tv/helix/clips?broadcaster_id=${broadcaster_id}`;
			const linkParams = [];

			if (params) {

				if (params.started_at) {
					linkParams.push(`started_at=${params.started_at}`);
				}
				if (params.ended_at) {
					linkParams.push(`ended_at=${params.ended_at}`);
				}
				if (params.after) {
					linkParams.push(`after=${params.after}`);
				}
				if (params.before) {
					linkParams.push(`before=${params.before}`);
				}
				if (params.first) {
					linkParams.push(`first=${params.first}`);
				}

			}

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			link += "?" + linkParams.join("&");

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}

	}
	/**
	 * ğŸ‘€ **Renvoi des informations sur toutes les diffusions sur Twitch**
	 * 
	 * ---
	 * @param {{
	* first?:number,
	* after?:string,
	* before?:string,
	* }} [params] **ParamÃ¨tres de filtrage** :
	* 
	* > â€¢ `first?` Le nombre maximum d'Ã©lÃ©ments Ã  renvoyer par page dans la rÃ©ponse. La taille minimale de la page est de 1 Ã©lÃ©ment par page et la taille maximale est de 100 Ã©lÃ©ments par page. La valeur par dÃ©faut est 20.  
	* > â€¢ `after?` Le curseur utilisÃ© pour obtenir la page suivante de rÃ©sultats. L'objet Pagination dans la rÃ©ponse contient la valeur du curseur. [Lire la suite](https://dev.twitch.tv/docs/api/guide/#pagination)  
	* > â€¢ `before ?` Le curseur utilisÃ© pour obtenir la page de rÃ©sultats prÃ©cÃ©dente. L'objet Pagination dans la rÃ©ponse contient la valeur du curseur. [Lire la suite](https://dev.twitch.tv/docs/api/guide/#pagination)
	* 
	* ---
	* @returns {Promise<{
	* ok:boolean,
	* statusText?:string,
	* error?:string,
	* result?Array<{
	* id:string,
	* name:string,
	* box_art_url:string,
	* igdb_id:string
	* }>
	* }>} **Renvoi une promesse d'objet** :
	* 
	* â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	* â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	* â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des jeux  
	* â€¢ `result?` La liste des diffusions. Les Ã©missions sont classÃ©es par nombre de tÃ©lÃ©spectateurs, les plus populaires en premier.  
	* > â€¢ `id` Un identifiant qui identifie la catÃ©gorie ou le jeu.  
	* > â€¢ `name` Le nom de la catÃ©gorie ou du jeu.  
	* > â€¢ `box_art_url` Une URL vers la pochette de la catÃ©gorie ou du jeu. Vous devez remplacer l'espace rÃ©servÃ© {width}x{height} par la taille d'image souhaitÃ©e.  
	* > `igdb_id` L'ID que [IGDB](https://www.igdb.com) utilise pour identifier ce jeu. Si l'ID IGDB n'est pas disponible pour Twitch, ce champ est dÃ©fini sur une chaÃ®ne vide.
	* 
	* ---
	* @example
	client.getTopGames().then(console.log);
	*/
	async getTopGames(params) {

		try {

			let link = `https://api.twitch.tv/helix/games/top`;
			const linkParams = [];

			if (params) {

				if (params.after) {
					linkParams.push(`after=${params.after}`);
				}
				if (params.before) {
					linkParams.push(`before=${params.before}`);
				}
				if (params.first) {
					linkParams.push(`first=${params.first}`);
				}

			}

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			link += "?" + linkParams.join("&");

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}

	}
	/**
	 * ğŸ‘€ **Renvoi des informations sur les catÃ©gories ou les jeux spÃ©cifiÃ©s.**  
	 * ğŸ’¡ **Note** : Vous pouvez obtenir jusqu'Ã  100 catÃ©gories ou jeux en spÃ©cifiant leur identifiant ou leur nom. Vous pouvez spÃ©cifier tous les identifiants, tous les noms ou une combinaison d'identifiants et de noms. Si vous spÃ©cifiez une combinaison d'ID et de noms, le nombre total d'ID et de noms ne doit pas dÃ©passer 100.
	 * 
	 * ---
	 * @param {Array<string>} gameNames Le nom de la catÃ©gorie ou du jeu Ã  obtenir. Le nom doit correspondre exactement au titre de la catÃ©gorie ou du jeu. Incluez ce paramÃ¨tre pour chaque catÃ©gorie ou jeu que vous souhaitez obtenir. Vous pouvez spÃ©cifier un maximum de 100 noms. Le point de terminaison ignore les noms en double et les noms introuvables.
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:Array<{
	 * id:string,
	 * name:string,
	 * box_art_url:string,
	 * igdb_id:string
	 * }>
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des jeux  
	 * â€¢ `result?` La liste des catÃ©gories et des jeux. La liste est vide si les catÃ©gories et jeux spÃ©cifiÃ©s nâ€™ont pas Ã©tÃ© trouvÃ©s.  
	 * > â€¢ `id` Un identifiant qui identifie la catÃ©gorie ou le jeu.  
	 * > â€¢ `name` Le nom de la catÃ©gorie ou du jeu.  
	 * > â€¢ `box_art_url` Une URL vers la pochette de la catÃ©gorie ou du jeu. Vous devez remplacer l'espace rÃ©servÃ© {width}x{height} par la taille d'image souhaitÃ©e.  
	 * > â€¢ `igdb_id` L'ID que [IGDB](https://www.igdb.com) utilise pour identifier ce jeu. Si l'ID IGDB n'est pas disponible pour Twitch, ce champ est dÃ©fini sur une chaÃ®ne vide.
	 * 
	 * ---
	 * @example
	 client.getGames(["Fortnite"]).then(console.log);
	 */
	async getGames(gameNames) {

		try {

			const map = gameNames.join('&name=');
			const link = `https://api.twitch.tv/helix/games?name=${map}`;

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}
		catch (error) {
			return { ok:false, error:error.stack };
		}

	}
	/**
	 * ğŸ‘€ **Obtient des informations sur une ou plusieurs vidÃ©os publiÃ©es. Vous pouvez obtenir des vidÃ©os par identifiant, par utilisateur ou par jeu/catÃ©gorie.**  
	 *  ğŸ’¡ **Note** : Vous pouvez appliquer plusieurs filtres pour obtenir un sous-ensemble de vidÃ©os. Les filtres sont appliquÃ©s sous forme dâ€™opÃ©ration ET Ã  chaque vidÃ©o. Par exemple, si la langue est dÃ©finie sur Â« de Â» et que game_id est dÃ©fini sur 21779, la rÃ©ponse inclut uniquement les vidÃ©os montrant des utilisateurs jouant Ã  League of Legends en allemand. Les filtres s'appliquent uniquement si vous obtenez des vidÃ©os par ID utilisateur ou ID de jeu.
	 * 
	 * ---
	 * @param {string} username Le nom d'utilisateur de l'utilisateur dont vous souhaitez obtenir la liste des vidÃ©os.
	 * 
	 * ---
	 * @param {{
	 * game_name?:string,
	 * language?:string,
	 * period?:"all"|"day"|"month"|"week",
	 * sort?:"time"|"trending"|"views",
	 * type?:"all"|"archive"|"highlight"|"upload",
	 * first?:number,
	 * after?:string,
	 * before?:string,
	 * }} [params] **ParamÃ¨tres de filtrage** :
	 * 
	 * > â€¢ `game_name?` Un nom de catÃ©gorie ou de jeu. La rÃ©ponse contient un maximum de 500 vidÃ©os montrant ce contenu. Pour obtenir les noms de catÃ©gories/de jeux, utilisez le point de terminaison Rechercher des catÃ©gories.  
	 * > â€¢ `language?` Un filtre utilisÃ© pour filtrer la liste des vidÃ©os en fonction de la langue dans laquelle le propriÃ©taire de la vidÃ©o diffuse. Par exemple, pour obtenir des vidÃ©os diffusÃ©es en allemand, dÃ©finissez ce paramÃ¨tre sur les deux lettres ISO 639-1. code pour lâ€™allemand (câ€™est-Ã -dire DE). Pour obtenir la liste des langues prises en charge, consultez [Langues de flux prises en charge](https://help.twitch.tv/s/article/linguals-on-twitch?lingual=en_US#streamlang). Si la langue nâ€™est pas prise en charge, utilisez Â« autre Â». SpÃ©cifiez ce paramÃ¨tre uniquement si vous spÃ©cifiez le paramÃ¨tre de requÃªte game_name.  
	 * > â€¢ `period?` Un filtre utilisÃ© pour filtrer la liste des vidÃ©os selon leur date de publication. Par exemple, les vidÃ©os publiÃ©es la semaine derniÃ¨re. La valeur par dÃ©faut est Â« tout Â», qui renvoie les vidÃ©os publiÃ©es dans toutes les pÃ©riodes.  
	 * > â€¢ `sort?` L'ordre dans lequel trier les vidÃ©os renvoyÃ©es. La valeur par dÃ©faut est Â« heure Â».  
	 * > â€¢ `type?` Un filtre utilisÃ© pour filtrer la liste des vidÃ©os par type de vidÃ©o. La valeur par dÃ©faut est Â« all Â», qui renvoie tous les types de vidÃ©o.  
	 * > â€¢ `first?` Le nombre maximum d'Ã©lÃ©ments Ã  renvoyer par page dans la rÃ©ponse. La taille minimale de la page est de 1 Ã©lÃ©ment par page et la taille maximale est de 100. La valeur par dÃ©faut est de 20.  
	 * > â€¢ `after?` Le curseur utilisÃ© pour obtenir la page suivante de rÃ©sultats. L'objet Pagination dans la rÃ©ponse contient la valeur du curseur. [Lire la suite](https://dev.twitch.tv/docs/api/guide/#pagination)  
	 * > â€¢ `before?` Le curseur utilisÃ© pour obtenir la page de rÃ©sultats prÃ©cÃ©dente. L'objet Pagination dans la rÃ©ponse contient la valeur du curseur. [Lire la suite](https://dev.twitch.tv/docs/api/guide/#pagination)
	 * 
	 * ---
	 * @returns {Promise<{
	 * ok:boolean,
	 * statusText?:string,
	 * error?:string,
	 * result?:Array<{
	 * id:string,
	 * stream_id:string,
	 * user_id:string,
	 * user_login:string,
	 * user_name:string,
	 * title:string,
	 * description:string,
	 * created_at:string,
	 * published_at:string,
	 * utl:string,
	 * thumbnail_url:string,
	 * viewable:string,
	 * view_count:number,
	 * language:string,
	 * type:"archive"|"highlight"|"upload",
	 * duration:string,
	 * muted_segments:Array<{
	 * duration:number,
	 * offset:number,
	 * }>|null,
	 * }>
	 * }>} **Renvoi une promesse d'objet** :
	 * 
	 * â€¢ `ok` : Ã‰tat de la requÃªte (true ou false)  
	 * â€¢ `statusText?` : Ã‰tat de la requÃªte (similaire Ã  error)  
	 * â€¢ `error?` : Erreur lors de la rÃ©cupÃ©ration des vidÃ©os  
	 * â€¢ `result?` La liste des vidÃ©os publiÃ©es qui correspondent aux critÃ¨res de filtre.  
	 * > â€¢ `id` Un identifiant qui identifie la vidÃ©o.  
	 * > â€¢ `stream_id` L'ID du flux d'oÃ¹ provient la vidÃ©o si le type de la vidÃ©o est Â« archive Â» ; sinon, nul.  
	 * > â€¢ `user_id` L'ID du diffuseur propriÃ©taire de la vidÃ©o.  
	 * > â€¢ `user_login` Le nom de connexion du diffuseur.  
	 * > â€¢ `user_name` Le nom d'affichage du diffuseur.  
	 * > â€¢ `title` Le titre de la vidÃ©o.  
	 * > â€¢ `description` La description de la vidÃ©o.  
	 * > â€¢ `created_at` La date et l'heure, en UTC, de la crÃ©ation de la vidÃ©o. L'horodatage est au format RFC3339.  
	 * > â€¢ `published_at` La date et l'heure, en UTC, de la publication de la vidÃ©o. L'horodatage est au format RFC3339.  
	 * > â€¢ `url` L'URL de la vidÃ©o.  
	 * > â€¢ `thumbnail_url` Une URL vers une image miniature de la vidÃ©o. Avant d'utiliser l'URL, vous devez remplacer les espaces rÃ©servÃ©s %{width} et %{height} par la largeur et la hauteur de la vignette que vous souhaitez renvoyer. SpÃ©cifiez la largeur et la hauteur en pixels. Ã‰tant donnÃ© que le CDN conserve le rapport de la vignette, celle-ci peut ne pas avoir la taille exacte que vous avez demandÃ©e.  
	 * > â€¢ `visible` L'Ã©tat visible de la vidÃ©o. Toujours dÃ©fini sur public.  
	 * > â€¢ `view_count` Le nombre de fois que les utilisateurs ont regardÃ© la vidÃ©o.  
	 * > â€¢ `langue` Le code de langue Ã  deux lettres ISO 639-1 dans lequel la vidÃ©o a Ã©tÃ© diffusÃ©e. Par exemple, le code de langue est DE si la vidÃ©o a Ã©tÃ© diffusÃ©e en allemand. Pour obtenir la liste des langues prises en charge, consultez [Langues de flux prises en charge](https://help.twitch.tv/s/article/linguals-on-twitch?lingual=en_US#streamlang). La valeur de langue est Â« autre Â» si la vidÃ©o a Ã©tÃ© diffusÃ©e dans une langue ne figurant pas dans la liste des langues prises en charge.  
	 * > â€¢ `type` Le type de la vidÃ©o.  
	 * > â€¢ `durÃ©e` La durÃ©e de la vidÃ©o au format de durÃ©e ISO 8601. Par exemple, 3 min 21 s reprÃ©sente 3 minutes 21 secondes.  
	 * > â€¢ `muted_segments` Les segments que la reconnaissance audio Twitch a dÃ©sactivÃ©s ; sinon, nul.  
	 * > > â€¢ `duration` La durÃ©e du segment muet, en secondes.  
	 * > > â€¢ `offset` Le dÃ©calage, en secondes, depuis le dÃ©but de la vidÃ©o jusqu'Ã  l'endroit oÃ¹ commence le segment coupÃ©.
	 * 
	 * ---
	 * @example
	 client.getVideos("twitchdev").then(console.log);
	 */
	async getVideos(username, params = {}) {

		try {

			const user = await this.getUsers([username]);

			if (!user.ok) {
				return { ok:false, error:user.error ?? user.statusText };
			}

			const user_id = user.result[0]?.id;

			let link = `https://api.twitch.tv/helix/videos?user_id=${user_id}`;
			const linkParams = [];

			if (params) {

				if (params.after) {
					linkParams.push(`after=${params.after}`);
				}
				if (params.before) {
					linkParams.push(`before=${params.before}`);
				}
				if (params.first) {
					linkParams.push(`first=${params.first}`);
				}
				if (params.game_name) {
					const game = await this.getGames([params.game_name]);
					if (!game.ok) {
						return { ok:false, error:game.error ?? game.statusText };
					}
					const id = game.result[0].id;
					linkParams.push(`game_id=${id}`);
				}
				if (params.language) {
					linkParams.push(`language=${params.language}`);
				}
				if (params.period) {
					linkParams.push(`period=${params.period}`);
				}
				if (params.sort) {
					linkParams.push(`sort=${params.sort}`);
				}
				if (params.type) {
					linkParams.push(`type=${params.type}`);
				}

			}

			if (this.isExpiredToken()) {
				await this.refreshToken();
			}

			link += "?" + linkParams.join("&");

			const _ = await fetch(link, {
				method:"GET",
				headers:{
					"Authorization":`${TwitchToken.token_type} ${TwitchToken.access_token}`,
					"Client-Id":this.clientId,
				},
			});

			if (!_.ok) {
				return { ok:false, statusText:_.statusText };
			}

			const result = await _.json();
			return { ok:true, result:result.data };

		}

		catch (error) {
			return { ok:false, error:error.stack };
		}

	}

};
